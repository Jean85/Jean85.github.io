<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Continuous deployment from GitLab CI to Kubernetes using Docker-in-Docker - Alessandro Lai</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Continuous deployment from GitLab CI to Kubernetes using Docker-in-Docker" />
<meta property="og:description" content="In the last month, I&rsquo;m working on two different PHP projects here at Facile.it: in the first one, which is new and still in development, I decided to adopt GitLab CI for the build, since we use GitLab CE for our Git repositories; I then created a continuous deployment pipeline for the staging environment, directly to a Kubernetes cluster, leveraging Docker Compose to make the configuration easier.
After, I decided to start migrating a previous, internal project of mine to the same approach, since it&rsquo;s currently in production with a dumb approach that provokes some downtime during deployments; on the contrary, doing a rolling deployment with Kubernetes is surprisingly easy!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://alessandrolai.dev/posts/continuous-deployment-from-gitlab-ci-to-k8s-using-docker-in-docker/" />
<meta property="og:image" content="https://alessandrolai.dev/images/avatar-alessandro-lai-square.jpg"/>
<meta property="article:published_time" content="2018-02-06T00:00:00+00:00" />
<meta property="article:modified_time" content="2018-02-06T00:00:00+00:00" />

		<meta itemprop="name" content="Continuous deployment from GitLab CI to Kubernetes using Docker-in-Docker">
<meta itemprop="description" content="In the last month, I&rsquo;m working on two different PHP projects here at Facile.it: in the first one, which is new and still in development, I decided to adopt GitLab CI for the build, since we use GitLab CE for our Git repositories; I then created a continuous deployment pipeline for the staging environment, directly to a Kubernetes cluster, leveraging Docker Compose to make the configuration easier.
After, I decided to start migrating a previous, internal project of mine to the same approach, since it&rsquo;s currently in production with a dumb approach that provokes some downtime during deployments; on the contrary, doing a rolling deployment with Kubernetes is surprisingly easy!">
<meta itemprop="datePublished" content="2018-02-06T00:00:00+00:00" />
<meta itemprop="dateModified" content="2018-02-06T00:00:00+00:00" />
<meta itemprop="wordCount" content="3799">
<meta itemprop="image" content="https://alessandrolai.dev/images/avatar-alessandro-lai-square.jpg"/>



<meta itemprop="keywords" content="Continuous integration,Continuous deployment,Docker,GitLab,Kubernetes," />

		<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://alessandrolai.dev/images/avatar-alessandro-lai-square.jpg"/>

<meta name="twitter:title" content="Continuous deployment from GitLab CI to Kubernetes using Docker-in-Docker"/>
<meta name="twitter:description" content="In the last month, I&rsquo;m working on two different PHP projects here at Facile.it: in the first one, which is new and still in development, I decided to adopt GitLab CI for the build, since we use GitLab CE for our Git repositories; I then created a continuous deployment pipeline for the staging environment, directly to a Kubernetes cluster, leveraging Docker Compose to make the configuration easier.
After, I decided to start migrating a previous, internal project of mine to the same approach, since it&rsquo;s currently in production with a dumb approach that provokes some downtime during deployments; on the contrary, doing a rolling deployment with Kubernetes is surprisingly easy!"/>

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	<link rel="stylesheet" href="/css/pr-66-fixes.css">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo logo--mixed">
		<a class="logo__link" href="/" title="Alessandro Lai" rel="home">
			<div class="logo__item logo__imagebox">
					<img class="logo__img" src="/images/logo-alessandro-lai.jpg">
				</div><div class="logo__item logo__text">
					<div class="logo__title">Alessandro Lai</div>
					<div class="logo__tagline">Personal site, blog, slide storage, rant box</div>
				</div>
		</a>
	</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">Menu</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/">
				
				<span class="menu__text">Home</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/who-am-i/">
				
				<span class="menu__text">Who am I</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/posts/">
				
				<span class="menu__text">Blog</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/talks/">
				
				<span class="menu__text">Talks</span>
				
			</a>
		</li>
	</ul>
</nav>

	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
    <article class="post">
        <header class="post__header">
            <h1 class="post__title">Continuous deployment from GitLab CI to Kubernetes using Docker-in-Docker</h1>
            <div class="post__meta meta">
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class="meta__text" datetime="2018-02-06T00:00:00Z">February 06, 2018</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2l1 2h8v11h-16v-13z"/></svg><span class="meta__text"><a class="meta__link" href="/categories/republished/" rel="category">Republished</a>
	</span>
</div></div>
        </header>
        <div class="content clearfix">
            <blockquote>
                <p>
                    This post was originally published on the
                    <a href="https://engineering.facile.it/blog/eng/continuous-deployment-from-gitlab-ci-to-k8s-using-docker-in-docker/" target="_blank">Facile.it Engineering blog</a>.
                </p>
            </blockquote>
        </div>
<div class="post__toc toc">
	<div class="toc__title">Page content</div>
	<div class="toc__menu">
		<nav id="TableOfContents">
  <ul>
    <li><a href="#the-gitlab-ciyml-configuration-file">The <code>.gitlab-ci.yml</code> configuration file</a></li>
    <li><a href="#pipeline-setup-and-docker-compose-configuration">Pipeline setup and Docker Compose configuration</a>
      <ul>
        <li><a href="#a-small-trick-cache-friendly-docker-images">A small trick: cache-friendly Docker images</a></li>
      </ul>
    </li>
    <li><a href="#the-jobs-definitions">The jobs definitions</a></li>
    <li><a href="#the-scary-part-deleting-docker-images">The scary part: deleting Docker images</a>
      <ul>
        <li><a href="#pushing-a-dummy-image">Pushing a dummy image</a></li>
        <li><a href="#obtaining-a-jwt-token-from-the-registry">Obtaining a JWT token from the registry</a></li>
        <li><a href="#getting-the-image-manifest">Getting the image manifest</a></li>
        <li><a href="#deleting-the-image">Deleting the image</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#building-images-for-the-deployment">Building images for the deployment</a></li>
    <li><a href="#the-deploy">The deploy</a></li>
    <li><a href="#the-cleanup-after-the-deploy">The cleanup after the deploy</a></li>
  </ul>
</nav>
	</div>
</div>
<div class="content post__content clearfix">
            <p>In the last month, I&rsquo;m working on two different PHP projects here at Facile.it: in the first one, which is new and still in development, I decided to adopt <strong>GitLab CI</strong> for the build, since we use GitLab CE for our Git repositories; I then created a <strong>continuous deployment pipeline</strong> for the staging environment, directly to a <strong>Kubernetes cluster</strong>, leveraging <strong>Docker Compose</strong> to make the configuration easier.</p>
<p>After, I decided to start migrating a previous, internal project of mine to the same approach, since it&rsquo;s currently in production with a dumb approach that provokes some downtime during deployments; on the contrary, <strong>doing a rolling deployment with Kubernetes is surprisingly easy</strong>!</p>
<p>A few days ago David Négrier‏ (<a href="https://twitter.com/david_negrier">@david_negrier</a>) published a blog posts about his way of doing continuous deployment from GitLab CI:</p>
<!-- raw HTML omitted -->
<p>This post immediately captured my attention, due to my current work: David in his post avoided the usage of Kubernetes to not add too much cognitive load, and wrote a very straightforward piece. On the other hand, in my case I wrote a kinda complicated pipeline, learning a few tricks and pitfalls in the process, so I decided to write this down and share my experience.</p>
<h1 id="the-basic-ci-pipeline">The basic CI pipeline</h1>
<p>This is how my basic pipeline looks like when it&rsquo;s building a branch while I&rsquo;m working on it:</p>
<p><img src="/images/continuous-deployment-from-gitlab-ci-to-k8s/basic-pipeline.png" alt="The basic pipeline"></p>
<p>Three simple stages:</p>
<ol>
<li><strong>Build CI</strong>: a CI image is built with the code baked in;</li>
<li><strong>Test</strong>: multiple jobs to do various verification tasks in parallel (tests, static analysis, code style&hellip;);</li>
<li><strong>Cleanup</strong>: deletion of the CI image built in the first step, to avoid bloating the Docker registry.</li>
</ol>
<p>Let&rsquo;s dive into the configuration details! For now, in the code examples, I will omit any piece that is needed for the deployment part; we will see that later.</p>
<h2 id="the-gitlab-ciyml-configuration-file">The <code>.gitlab-ci.yml</code> configuration file</h2>
<p>The <a href="https://docs.gitlab.com/ee/ci/">GitLab CI</a> is configurable just by adding a <code>.gitlab-ci.yml</code> file to the root of your project. The configuration for this first part looks like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">image</span>: <span style="color:#ae81ff">gitlab.facile.it/facile/my-project/docker-compose:1.2</span>

<span style="color:#f92672">services</span>:
- <span style="color:#f92672">name</span>: <span style="color:#ae81ff">docker:17.12.0-dind</span>
  <span style="color:#f92672">alias</span>: <span style="color:#ae81ff">docker</span>
  <span style="color:#f92672">command</span>: [<span style="color:#e6db74">&#34;--registry-mirror&#34;</span>, <span style="color:#e6db74">&#34;https://registry-mirror.facile.it&#34;</span>]

<span style="color:#f92672">variables</span>:
  <span style="color:#f92672">GIT_DEPTH</span>: <span style="color:#e6db74">&#34;1&#34;</span>
  <span style="color:#f92672">DOCKER_DRIVER</span>: <span style="color:#e6db74">&#34;overlay2&#34;</span>
  <span style="color:#f92672">DOCKER_HOST</span>: <span style="color:#e6db74">&#34;tcp://docker:2375&#34;</span>
</code></pre></div><p>The <code>services</code> section allows me to declare a Docker container that will be spun up by GitLab CI each time and that will host the Docker daemon that I will use. Here resides <strong>the main difference</strong> between David&rsquo;s and my approach: in his case, he is using the host&rsquo;s machine Docker daemon, in my case I&rsquo;m using an isolated daemon, <strong>a real Docker-in-Docker approach</strong>.</p>
<p>The combination of the <code>alias: docker</code> setting and the <code>DOCKER_HOST</code> environment variable points our job to the D-in-D daemon socket; the <code>--registry-mirror</code> option let the daemon use our internal registry mirror to speed up pulling official images; last but not least, the <code>DOCKER_DRIVER</code> uses the <code>overlay2</code> filesystem for the Docker build, which is <strong>faster and less space consuming</strong> (I suggest you to use that on your local Linux machines too!).</p>
<blockquote>
<p>David&rsquo;s approach may be a bit <strong>faster</strong>, because the daemon is always the same and retains some build and image cache between jobs and builds, but <del>it requires to run <strong>privileged jobs</strong>, and</del> it&rsquo;s not isolated, so it may incur in some issues or slowdowns if <strong>multiple builds</strong> run at the same time, messing up image tags.</p>
<p>My approach is a bit more <strong>robust</strong>, but it&rsquo;s overall <strong>slower</strong>, because each job is <strong>totally isolated</strong> (which is good), but on the downside it has no memory of previous builds, so no cache is available: we will have to <strong>pull from the registry each time</strong>.
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<strong>2018-02-07 ERRATA</strong>: <a href="https://twitter.com/storresi">Stefano Torresi</a> (privately) and <a href="https://www.reddit.com/r/kubernetes/comments/7vomn5/continuous_deployment_from_gitlab_ci_to/dttzc28/">/u/veloxlector</a> (on Reddit) made me realize that my approach still requires a privileged runner, so that doesn&rsquo;t change with my approach; the privileged execution is <a href="https://github.com/docker-library/docs/blob/master/docker/README.md#start-a-daemon-instance">always required when doing Docker-in-Docker</a>. This reduces my security claims, but my main aim was isolation.</p>
</blockquote>
<p>The <code>GIT_DEPTH</code> option makes the project clone process in each job a bit faster, pulling only the current commit, not the whole Git history.</p>
<p>The <code>image</code> option allows you to require a different base image in which to execute each job of the pipeline. In my case the image is pretty simple, because it&rsquo;s created from the base Docker image, and has in addition Docker Compose and <code>kubectl</code>, the <a href="https://kubernetes.io/docs/reference/kubectl/overview/">command line interface for Kubernetes</a>. My Dockerfile looks like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-dockerfile" data-lang="dockerfile"><span style="color:#66d9ef">FROM</span><span style="color:#e6db74"> docker:17.12.0-ce</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">ARG</span> DOCKER_COMPOSE_VERSION<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>.18.0<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span> <span style="color:#75715e"># install Docker Compose</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">RUN</span> apk add --no-cache curl py-pip bash <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    <span style="color:#f92672">&amp;&amp;</span> pip install docker-compose<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span> <span style="color:#75715e"># install kubectl</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">RUN</span> wget https://storage.googleapis.com/kubernetes-release/release/v1.9.1/bin/linux/amd64/kubectl <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -O /usr/local/bin/kubectl <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    <span style="color:#f92672">&amp;&amp;</span> chmod +x /usr/local/bin/kubectl<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><h2 id="pipeline-setup-and-docker-compose-configuration">Pipeline setup and Docker Compose configuration</h2>
<p>The next part of my configuration looks like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">stages</span>:
  - <span style="color:#ae81ff">Build</span>
  - <span style="color:#ae81ff">Test</span>
  - <span style="color:#ae81ff">Cleanup</span>

<span style="color:#f92672">before_script</span>:
  - <span style="color:#ae81ff">docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY</span>
  - <span style="color:#ae81ff">cp docker-compose.yml.gitlab docker-compose.override.yml</span>
</code></pre></div><p>In here I configured the sequence of <strong>stages</strong> in the pipeline, and I configured a <code>before_script</code> section to be executed before each job. The first instruction <strong>logs into the private Docker registry</strong> that GitLab gives us along any project (if enabled), in which I decided to store my Docker images.</p>
<blockquote>
<p>GitLab CI jobs automatically have the <code>$CI_JOB_TOKEN</code> and <code>$CI_REGISTRY</code> environment variables populated to easily do that: the first one is a fresh unique token, which is <a href="https://docs.gitlab.com/ee/user/project/new_ci_build_permissions_model.html#job-token">generated for each job</a>; the second one is the URL of the registry associated with the current project; see the <a href="https://docs.gitlab.com/ce/ci/variables/README.html">GitLab CI documentation</a> for more details.</p>
</blockquote>
<p>The second instruction depends on <strong>how I organized my Docker Compose files</strong> to help me during development and in the pipeline too. I use 4 separated files:</p>
<ul>
<li><code>docker-compose.yml</code> is the base file, with the <strong>basic configuration</strong>.</li>
<li><code>docker-compose.override.yml</code> <strong>overrides</strong> stuff when needed; the name is <a href="https://docs.docker.com/compose/extends/#understanding-multiple-compose-files">standard with the Docker Compose v3 configurations</a>, so you don&rsquo;t have to specify it in the CLI, it&rsquo;s automatically picked up; this file is not committed and ignored by Git, because I use it to give each developer the freedom to customize the containers behavior, like ports or volumes.</li>
<li><code>docker-compose.override.yml.dist</code> is a committed file with the <strong>suggested override</strong> configuration (default exposed ports, default mounts&hellip;).</li>
<li><code>docker-compose.yml.gitlab</code> is an override file that I use <strong>only during the build</strong>, so that&rsquo;s why we need that <code>cp</code> instruction.</li>
</ul>
<p>I will show you just the last file, which looks like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">version</span>: <span style="color:#e6db74">&#39;3.2&#39;</span>

<span style="color:#f92672">services</span>:
  <span style="color:#f92672">php</span>:
    <span style="color:#f92672">image</span>: <span style="color:#ae81ff">${CI_IMAGE_COMMIT_TAG}</span>
    <span style="color:#f92672">build</span>:
      <span style="color:#f92672">dockerfile</span>: <span style="color:#ae81ff">docker/development/php-ci/Dockerfile</span>
      <span style="color:#f92672">context</span>: <span style="color:#ae81ff">.</span>
      <span style="color:#f92672">cache_from</span>:
        - <span style="color:#ae81ff">${CI_IMAGE_BRANCH_TAG}</span>
  <span style="color:#f92672">php-cache</span>:
    <span style="color:#f92672">image</span>: <span style="color:#ae81ff">${CI_IMAGE_BRANCH_TAG}</span>
</code></pre></div><p>I declared in my <code>php</code> service both the <code>image</code> and <code>build</code> sections, so I&rsquo;m able to use this definition in all my jobs, <strong>both for building and executing</strong>. I&rsquo;m also able to move the <code>Dockerfile</code>s inside a dedicated directory, thanks to the usage of the <code>dockerfile</code> and <code>context</code> options with different paths.</p>
<p>It&rsquo;s also very important to use <code>version: '3.2'</code>, because it&rsquo;s needed to use the <code>cache_from</code> option: since we do not have any cache in the daemon, I <strong>tag the image twice</strong>, once with the <strong>commit hash</strong> and once with the <strong>branch name</strong>; in this way I can pull the <code>php-cache</code> service with the branch tag as a cache from the previous build.</p>
<p>As you can see I&rsquo;m using <strong>environment variables</strong> to define the image names. I do that in the GitLab CI configuration so I can <strong>define them only once</strong> and use them everywhere:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">variables</span>:
    <span style="color:#75715e"># ...</span>
    <span style="color:#f92672">CI_IMAGE_NAME</span>: <span style="color:#ae81ff">facile/my-project/php-ci</span>
    <span style="color:#f92672">CI_IMAGE_COMMIT_TAG</span>: <span style="color:#ae81ff">$CI_REGISTRY/$CI_IMAGE_NAME:$CI_COMMIT_SHA</span>
    <span style="color:#f92672">CI_IMAGE_BRANCH_TAG</span>: <span style="color:#ae81ff">$CI_REGISTRY/$CI_IMAGE_NAME:$CI_COMMIT_REF_SLUG</span>
</code></pre></div><p>I still leverage GitLab&rsquo;s <code>$CI_REGISTRY</code> variable to compose the names, so basically my image names will be:</p>
<ul>
<li><code>gitlab.facile.it/facile/my-project/php-ci:79aef00e3893a39102ffc394bf96782e57adb956</code></li>
<li><code>gitlab.facile.it/facile/my-project/php-ci:branch-name</code></li>
</ul>
<p>Just remember to use <code>$CI_COMMIT_REF_SLUG</code> for the second tag, because it has slashes and other invalid chars stripped out automatically.</p>
<h3 id="a-small-trick-cache-friendly-docker-images">A small trick: cache-friendly Docker images</h3>
<p>To make this process work smoothly, you should write your <strong>Dockerfile in a cache-friendly manner</strong>. To obtain that, we must leverage the layer-based structure of the images, and <strong>put the stuff that changes more often in the latter layers</strong>, and vice versa the stuff that never changes up in the first ones. In this specific case we&rsquo;re talking about a PHP/Symfony application and, starting from some advice that I got from my colleague <a href="https://twitter.com/thomasvargiu">Thomas</a>, I wrote down this Dockerfile:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-dockerfile" data-lang="dockerfile"><span style="color:#66d9ef">FROM</span><span style="color:#e6db74"> gitlab.facile.it/facile/my-project/php-base</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">MAINTAINER</span><span style="color:#e6db74"> Alessandro Lai &lt;alessandro.lai@facile.it&gt;</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">ARG</span> COMPOSER_FLAGS<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;--no-interaction --no-suggest --no-progress --ansi --prefer-dist&#34;</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">ENV</span> SYMFONY_ENV<span style="color:#f92672">=</span>test

<span style="color:#66d9ef">USER</span><span style="color:#e6db74"> blaine</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">COPY</span> composer.* ./<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">RUN</span> composer install $COMPOSER_FLAGS --no-scripts --no-autoloader<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">COPY</span> . .<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">RUN</span> composer install $COMPOSER_FLAGS <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    <span style="color:#f92672">&amp;&amp;</span> bin/console cache:warmup --ansi --env<span style="color:#f92672">=</span>$SYMFONY_ENV<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><p>The base image that I extend contains everything that doesn&rsquo;t change often: PHP version, extensions, a non-root user. Then, I start adding stuff on top, using this sequence:</p>
<ul>
<li>copy the <code>composer.json</code> and <code>composer.lock</code> files;</li>
<li><code>composer install</code> to populate the vendor, using the <code>--no-scripts --no-autoloader</code> options to skip anything else;</li>
<li>copy everything else (I use the <code>.dockerignore</code> file to avoid considering garbage files here, <a href="https://docs.docker.com/engine/reference/builder/#dockerignore-file">see docs</a>);</li>
<li>repeat the <code>composer install</code> step, to dump the autoloader and run all the <code>post-install</code> scripts;</li>
<li>warm up the Symfony cache, so we ship that with the image too.</li>
</ul>
<p>In this way, I&rsquo;m literally <strong>caching my vendor folder inside a single Docker image layer</strong>, and changing the Composer files will automatically invalidate that cache; also, copying all the other source files later allows me to not lose that layer when the vendor shouldn&rsquo;t change.</p>
<p>Remember, <strong>that layer with the source code will change every time</strong>, since you&rsquo;ve obviously just committed something new!</p>
<h2 id="the-jobs-definitions">The jobs definitions</h2>
<p>At this point we just need to define the jobs! The <strong>build job</strong> is defined like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">build-image</span>:
  <span style="color:#f92672">stage</span>: <span style="color:#ae81ff">Build CI</span>
  <span style="color:#f92672">script</span>:
    - <span style="color:#ae81ff">docker-compose pull --ignore-pull-failures php-cache</span>
    - <span style="color:#ae81ff">docker-compose build php</span>
    - <span style="color:#ae81ff">docker tag $CI_IMAGE_COMMIT_TAG $CI_IMAGE_BRANCH_TAG</span>
    - <span style="color:#ae81ff">docker-compose push php php-cache</span>
</code></pre></div><ul>
<li><strong>pull</strong> the branch image as <strong>cache</strong> (<code>--ignore-pull-failures</code> avoids failures on the first commit of a branch);</li>
<li><strong>build</strong> the image with the commit tag;</li>
<li><strong>re-tag</strong> the freshly built image with the branch tag;</li>
<li><strong>push</strong> both back into the registry.</li>
</ul>
<p>Then we can pass onto the <strong>test stage</strong>. If I need multiple services, like for functional tests, I do it like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">test-coverage</span>:
  <span style="color:#f92672">stage</span>: <span style="color:#ae81ff">Test</span>
  <span style="color:#f92672">coverage</span>: <span style="color:#e6db74">&#39;/^\s*Lines:\s*\d+.\d+\%/&#39;</span>
  <span style="color:#f92672">script</span>:
    - <span style="color:#ae81ff">docker-compose pull --parallel php mysql</span>
    - <span style="color:#ae81ff">docker-compose run --rm php vendor/bin/phing ci</span>
</code></pre></div><ul>
<li><strong>pull</strong> all the needed images with the <code>--parallel</code> option to speed up;</li>
<li><strong>run</strong> the needed task; in my case I use <code>phing</code> (a <a href="https://packagist.org/packages/phing/phing">PHP porting of Ant</a>) inside the container to call everything with a single command;</li>
<li>The <code>coverage</code> options contains a regex that picks up the coverage percentage from PHPUnit&rsquo;s <code>--coverage-text</code> option.</li>
</ul>
<p>If instead I need to execute just simple tasks, without external services, I can skip the <code>pull</code> command completely:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">phpstan</span>:
  <span style="color:#f92672">stage</span>: <span style="color:#ae81ff">Test</span>
  <span style="color:#f92672">script</span>:
    - <span style="color:#ae81ff">docker-compose run --rm --no-deps php phing phpstan_check</span>
</code></pre></div><p>This is possible because I need just one image which will be pulled implicitly by Docker Compose, so the <code>--parallel</code> option is useless here; I also have to remember to use <code>--no-deps</code> to avoid pulling linked services, if for example my base configuration defines a dependency to other containers (like the database).</p>
<h2 id="the-scary-part-deleting-docker-images">The scary part: deleting Docker images</h2>
<p>Up until now, it was all straightforward and easy; the difficult part comes with the last stage, the <strong>cleanup</strong>.</p>
<p>With the process that I have shown this far, I&rsquo;m building an image for each build, since I&rsquo;m <strong>shipping my code inside the container</strong>; this approach is the <strong>most similar to what happens in production</strong> (that&rsquo;s why I&rsquo;ve chosen it), but it has a big downside: you may waste a lot of space with old images pushed to your Docker registry.</p>
<p>This issue is particularly annoying because there&rsquo;s no automated feature in the GitLab&rsquo;s registry to clean them up, up to the point where there are multiple, long-standing issues still open on their tracker about this problem:</p>
<ul>
<li><a href="https://gitlab.com/gitlab-org/gitlab-ce/issues/20176">#20176 - Provide a programmatic method to delete images/tags from the registry</a></li>
<li><a href="https://gitlab.com/gitlab-org/gitlab-ce/issues/21608">#21608 - Container Registry API</a></li>
<li><a href="https://gitlab.com/gitlab-org/gitlab-ce/issues/25322">#25322 - Create a mechanism to clean up old container image revisions</a></li>
<li><a href="https://gitlab.com/gitlab-org/gitlab-ce/issues/28970">#28970 - Delete from registry images for merged branches</a></li>
<li><a href="https://gitlab.com/gitlab-org/gitlab-ce/issues/39490">#39490 - Allow to bulk delete docker images</a></li>
<li><a href="https://gitlab.com/gitlab-org/gitlab-ce/issues/40096">#40096 - pipeline user $CI_REGISTRY_USER lacks permission to delete its own images</a></li>
</ul>
<p>Last but not least, <strong>Docker tags are not first class citizens</strong> for the Docker registry API (see <a href="https://github.com/docker/distribution/issues/1859#issuecomment-236013971">this GitHub issue</a> and the <a href="https://github.com/docker/distribution/pull/173">related PR</a>).</p>
<p>What does that mean? Simply put, <strong>a Docker image tag is not a resource</strong> that you can easily delete using the Docker APIs, <strong>it&rsquo;s a simple link</strong>. This means that you delete images, not tags; hence, if your image had multiple tags attached to it, you&rsquo;re <strong>cascade-deleting all related tags</strong> without knowing.</p>
<p>To overcome those issues, I&rsquo;ve tinkered a lot to obtain a clear and easy way to delete my CI image after the build. After many trial &amp; error attempts, I obtained this workflow:</p>
<ul>
<li><strong>push a dummy image</strong> to override the tag and point it elsewhere</li>
<li>obtain a <strong>JWT token from the registry</strong> (with proper permissions for deletion)</li>
<li>obtain the <strong>SHA digest</strong> of the dummy image</li>
<li><strong>delete</strong> the image (finally!)</li>
</ul>
<p>The GitLab CI job is defined like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">delete-ci-image</span>:
  <span style="color:#f92672">stage</span>: <span style="color:#ae81ff">Cleanup</span>
  <span style="color:#f92672">when</span>: <span style="color:#ae81ff">always</span>
  <span style="color:#f92672">script</span>:
    - <span style="color:#ae81ff">bin/docker-util/dummy-tag.sh $IMAGE</span>
    - <span style="color:#ae81ff">TOKEN=$(bin/docker-util/get-registry-token.sh $IMAGE)</span>
    - <span style="color:#ae81ff">MANIFEST=$(bin/docker-util/get-manifest.sh $IMAGE $TOKEN)</span>
    - <span style="color:#ae81ff">bin/docker-util/delete-image.sh $IMAGE $MANIFEST $TOKEN</span>
</code></pre></div><p><code>when: always</code> is needed to run the job even if the build fails. The other steps are conveniently stored inside bash scripts, for reusability.</p>
<h3 id="pushing-a-dummy-image">Pushing a dummy image</h3>
<p>The script that pushes the dummy image, <code>dummy-tag.sh</code>, accepts as a single argument the full Docker image name complete with tag:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">#!/usr/bin/env bash
</span><span style="color:#75715e"></span>
DIR<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;/tmp/docker-dummy&#39;</span>
mkdir -p $DIR

<span style="color:#75715e"># generate a file containing a random string</span>
head /dev/urandom | tr -dc A-Za-z0-9 | head -c <span style="color:#ae81ff">13</span> ; echo <span style="color:#e6db74">&#39;&#39;</span> &gt; <span style="color:#e6db74">${</span>DIR<span style="color:#e6db74">}</span>/dummyfile 
<span style="color:#75715e"># generate the dummy image with only that one file </span>
echo <span style="color:#e6db74">&#34;FROM scratch&#34;</span> &gt; <span style="color:#e6db74">${</span>DIR<span style="color:#e6db74">}</span>/Dockerfile
echo <span style="color:#e6db74">&#34;ADD dummyfile .&#34;</span> &gt;&gt; <span style="color:#e6db74">${</span>DIR<span style="color:#e6db74">}</span>/Dockerfile
<span style="color:#75715e"># build and push it</span>
docker build -t $1 <span style="color:#e6db74">${</span>DIR<span style="color:#e6db74">}</span>/
docker push $1
</code></pre></div><p>Using <code>FROM scratch</code> I&rsquo;m able to create an empty image (<a href="https://docs.docker.com/develop/develop-images/baseimages/">see docs</a>), so the <strong>final result is ~100 bytes</strong>, probably the smallest possible. I just store inside a single file with a randomized string, so the dummy image is different each time and I avoid issues with concurrent builds with concurrent push/delete actions on the registry.</p>
<h3 id="obtaining-a-jwt-token-from-the-registry">Obtaining a JWT token from the registry</h3>
<p>The script that obtains the token needs to know <strong>on which image</strong> we have to operate, because the permission are granted very specifically on that. Also, <strong>you will need to have a <a href="https://docs.gitlab.com/ce/user/profile/personal_access_tokens.html">GitLab Personal Access Token</a></strong> available in an environment variable, because the normal token will not have enough permission to do what we need (it would be privilege escalation!):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">#!/usr/bin/env bash
</span><span style="color:#75715e"></span>
splitImageName $1

curl https://gitlab.facile.it/jwt/auth <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    --get <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    --silent --show-error <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -d client_id<span style="color:#f92672">=</span>docker <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -d offline_token<span style="color:#f92672">=</span>true <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -d service<span style="color:#f92672">=</span>container_registry <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -d <span style="color:#e6db74">&#34;scope=repository:</span>$IMAGE<span style="color:#e6db74">:pull,*&#34;</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    --fail <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    --user alai:$PERSONAL_ACCESS_TOKEN <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    | sed -r <span style="color:#e6db74">&#34;s/(\{\&#34;token\&#34;:\&#34;|\&#34;\})//g&#34;</span>
</code></pre></div><p>The script, like before, requires as a single argument the full image name; the <code>splitImageName</code> function (omitted) just splits it and exports the result in 3 separated variables: <code>$REGISTRY</code>, <code>$IMAGE</code> and <code>$TAG</code>; we will need just <code>$IMAGE</code> for now.</p>
<p>So basically we issue <strong>a GET request</strong> to a GitLab API endpoint that looks like this:</p>
<pre><code>https://gitlab.facile.it/jwt/auth?client_id=docker&amp;offline_token=true&amp;service=container_registry&amp;scope=repository:facile/my-project/php-ci:pull,*
</code></pre><p>The last part, <code>pull,*</code> is really important: those are the permission that we are requiring, and the <code>*</code> is what will allow us to delete the image. Finally, the response will be in JSON, with a single <code>token</code> property, and <code>sed</code> will take care of stripping out all the JSON from the output.</p>
<h3 id="getting-the-image-manifest">Getting the image manifest</h3>
<p>Now that we have the authorization part in place, we can start using the <a href="https://docs.docker.com/registry/spec/api/#detail">Docker registry API</a>, which has a resource called <code>manifest</code> that describes an image. The <code>get-manifest.sh</code> script will require 2 arguments, the full image name (again) and the JWT token (that we just obtained):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">#!/usr/bin/env bash
</span><span style="color:#75715e"></span>
splitImageName $1

curl https://$REGISTRY/v2/$IMAGE/manifests/$TAG <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    --head <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    --fail <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    --silent --show-error <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -H <span style="color:#e6db74">&#34;accept: application/vnd.docker.distribution.manifest.v2+json&#34;</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -H <span style="color:#e6db74">&#34;authorization: Bearer </span>$REGISTRY_TOKEN<span style="color:#e6db74">&#34;</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    | grep -i <span style="color:#e6db74">&#34;Docker-Content-Digest&#34;</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    | grep -oi <span style="color:#e6db74">&#34;sha256:\w\+&#34;</span>

</code></pre></div><p>This time we are using all the 3 variables from the <code>splitImageName</code> function, and we are issuing <strong>a HEAD request</strong>, because what we need is <strong>a header of the response</strong>: <code>Docker-Content-Digest</code>. This header contains the <strong>SHA digest of the manifest</strong>, that we will use to reference what we want to delete in the next (and last) step. I then used <code>grep</code> twice: first to select the line of the output containing the header, and then to strip everything out except the digest.</p>
<p>The API endpoint looks like this:</p>
<pre><code>https://gitlab.facile.it/v2/facile/my-project/php-ci/manifests/my-tag-that-i-want-to-delete
</code></pre><h3 id="deleting-the-image">Deleting the image</h3>
<p>Now that we have everything that we need, we can finally use the <code>delete-image.sh</code> script; it requires three arguments:</p>
<ul>
<li>the full image name (again)</li>
<li>the SHA digest of the manifest</li>
<li>the token (again)</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">#!/usr/bin/env bash
</span><span style="color:#75715e"></span>
splitImageName $1
echo <span style="color:#e6db74">&#34;Deleting image...&#34;</span>

curl <span style="color:#e6db74">&#34;https://</span>$REGISTRY<span style="color:#e6db74">/v2/</span>$IMAGE<span style="color:#e6db74">/manifests/</span>$2<span style="color:#e6db74">&#34;</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -X DELETE <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    --fail <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    --silent --show-error <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -H <span style="color:#e6db74">&#34;accept: application/vnd.docker.distribution.manifest.v2+json&#34;</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -H <span style="color:#e6db74">&#34;authorization: Bearer </span>$REGISTRY_TOKEN<span style="color:#e6db74">&#34;</span>
</code></pre></div><p>We are issuing <strong>a DELETE request</strong> to the manifest endpoint, using the <strong>SHA digest as an identifier</strong> for the specific resource that we want to delete; this last API endpoint looks like the previous one:</p>
<pre><code>https://gitlab.facile.it/v2/facile/my-project/php-ci/manifests/9170f905754579832799afb8e65c89441c794596eb1c4fe2ac88e4a8ff1dfec0
</code></pre><h1 id="doing-continuous-deployment">Doing continuous deployment</h1>
<p>Now that we have our CI pipeline in place, we can start doing <strong>continuous deployment</strong>! It&rsquo;s just a matter of adding a few new jobs to the pipeline, and some stages too (new one in <strong>bold</strong>):</p>
<ul>
<li>Build CI</li>
<li>Test</li>
<li><strong>Build prod</strong></li>
<li><strong>Deploy</strong></li>
<li>Cleanup (with a <strong>new job</strong>)</li>
</ul>
<h2 id="building-images-for-the-deployment">Building images for the deployment</h2>
<p>The new <strong>build prod</strong> stage will contain job(s) to build the container that will be shipped in production. I applied the same tricks as before, so I still write <strong>cache-friendly Dockerfiles</strong>, and I <strong>double-tag the images</strong> (with <code>prod</code> and <code>prod-$CI_COMMIT_SHA</code>) to use the previous one as cache, and to have a specific tag to use later, in the deploy job.</p>
<p>So, my build job does this simple sequence:</p>
<ul>
<li>pull with <code>--ignore-pull-failures</code> the previous image, as before;</li>
<li>build the prod image with the specific <code>prod-$CI_COMMIT_SHA</code> commit tag;</li>
<li>push it back to the registry.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">build-prod-images</span>:
  <span style="color:#f92672">stage</span>: <span style="color:#ae81ff">Build prod</span>
  <span style="color:#f92672">cache</span>:
    <span style="color:#f92672">paths</span>:
    - <span style="color:#ae81ff">node_modules/</span>
  <span style="color:#f92672">script</span>:
    - <span style="color:#ae81ff">docker-compose pull --ignore-pull-failures fpm-prod</span>
    - <span style="color:#ae81ff">docker-compose build fpm-prod</span>
    - <span style="color:#ae81ff">docker-compose push fpm-prod</span>
  <span style="color:#f92672">only</span>: <span style="color:#75715e">&amp;deployable-branches</span>
    - <span style="color:#ae81ff">master</span>
    - <span style="color:#ae81ff">an-other-deployable-branch</span>
</code></pre></div><p>Note that <strong>I&rsquo;m not pushing the generic <code>prod</code> tag for now</strong>, I&rsquo;m waiting to have a successful deployment first. This job can also be duplicated if you need to build multiple images with each deployment.</p>
<p>The other notable part of this job definition is the <code>only</code> directive. It&rsquo;s obviously needed to make the job <a href="https://docs.gitlab.com/ce/ci/yaml/README.html#only-and-except-simplified">run only on certain branches</a>, but the interesting part is the appended <code>&amp;deployable-branches</code> string: it&rsquo;s a <strong>YAML anchor</strong>. I&rsquo;m basically bookmarking the array values for the <code>only</code> directive, so I can reuse them in the next CD jobs.</p>
<h2 id="the-deploy">The deploy</h2>
<p>Finally, we can deploy our application to the Kubernetes cluster!</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">deploy</span>:
  <span style="color:#f92672">stage</span>: <span style="color:#ae81ff">Deploy</span>
  <span style="color:#f92672">environment</span>:
    <span style="color:#f92672">name</span>: <span style="color:#ae81ff">prod</span>
    <span style="color:#f92672">url</span>: <span style="color:#ae81ff">https://my-project.facile.it/</span>
  <span style="color:#f92672">script</span>:
    - <span style="color:#ae81ff">kubectl set image deployment/my-project php-container=&#34;${PROD_IMAGE_PHP_COMMIT_TAG}&#34;</span>
    - <span style="color:#ae81ff">kubectl rollout status deployment/my-project</span>
  <span style="color:#f92672">only</span>: <span style="color:#75715e">*deployable-branches</span>
</code></pre></div><p>Using the <strong>YAML anchor reference</strong> <code>*deployable-branches</code> (yes, they use a pointer-like syntax) I reuse the previous values, so if I decide to deploy a new, particular branch, I don&rsquo;t have to specify it in every deploy-related job, and risk forgetting one (yes, it happened to me).</p>
<p>Here we are <strong>finally using <code>kubectl</code> to do the deploy</strong>!</p>
<blockquote>
<p>To authenticate into the cluster with <code>kubectl</code>, you normally have to create a YAML config in your home directory; luckily, in the GitLab CI you can take a shortcut enabling the <strong>Kubernetes integration</strong> <a href="https://docs.gitlab.com/ee/user/project/integrations/kubernetes.html">(see docs)</a>, so GitLab will login into the cluster using a <code>serviceaccount</code>, which is basically a <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/">login for non-humans</a>. The integration will leverage environment variables to feed the configuration to <code>kubectl</code> automatically, so you just have to issue commands with it, it will just work.</p>
</blockquote>
<p>The deployment with <code>kubectl</code> is pretty straightforward: using the <code>kubectl set image</code> command we set a new image in our <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">deployment configuration</a>; <strong>the cluster will detect that we specified a different image</strong> and it will automatically start a rolling deployment to substitute the available containers with the new, requested tag.</p>
<blockquote>
<p>Note that <strong>using a commit-specific tag is critical</strong> here, because otherwise the deployment will not be triggered; if you want to trigger a deploy without using specific tags, you will have to append the SHA digests of the image, with <code>image:tag@${SHA}</code>; this will obviously mean that you will have to retrieve it, which can be less practical.</p>
</blockquote>
<p>The next command, <code>kubectl rollout status</code>, watches the advancement of the deploy and exits with a status code that reflect the result of the rollout, so it&rsquo;s perfect to be called in a build:</p>
<pre><code>$ kubectl rollout status deployment/my-application
Waiting for rollout to finish: 1 old replicas are pending termination...
Waiting for rollout to finish: 1 old replicas are pending termination...
deployment &quot;my-application&quot; successfully rolled out
</code></pre><p>The <code>environment</code> option enable the usage of the <a href="https://docs.gitlab.com/ce/ci/environments.html">GitLab Environments</a>, so my deploys are tracked.</p>
<h2 id="the-cleanup-after-the-deploy">The cleanup after the deploy</h2>
<p>As for the CI build, we will have to clean up older images after successfully deploying the application:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">delete-old-prod-image</span>:
  <span style="color:#f92672">stage</span>: <span style="color:#ae81ff">Cleanup</span>
  <span style="color:#f92672">script</span>:
    - <span style="color:#ae81ff">bin/docker-util/delete-old-prod-image.sh $PROD_IMAGE_PHP_GENERIC_TAG $PROD_IMAGE_PHP_COMMIT_TAG</span>
  <span style="color:#f92672">only</span>: <span style="color:#75715e">*deployable-branches</span>
</code></pre></div><p>I use the <code>*deployable-branches</code> here too, and a bash script to wrap everything in one file; the script will require two arguments (the generic and the commit-specific tag) and will execute this sequence of operations:</p>
<ul>
<li>retrieve a JWT token for the registry, as before;</li>
<li>retrieve the SHA digest of the previous image, using the generic tag;</li>
<li>pull the specific image;</li>
<li>re-tag and push it with the generic tag;</li>
<li>delete the previous image.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">#!/usr/bin/env bash
</span><span style="color:#75715e"></span>
OLD_IMAGE<span style="color:#f92672">=</span>$1
NEW_IMAGE<span style="color:#f92672">=</span>$2

echo <span style="color:#e6db74">&#34;Retrieving manifests of previous image using generic tag...&#34;</span>
TOKEN<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>bin/docker-util/get-registry-token.sh <span style="color:#e6db74">${</span>NEW_IMAGE<span style="color:#e6db74">}</span><span style="color:#66d9ef">)</span>
MANIFEST<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>bin/docker-util/get-manifest.sh <span style="color:#e6db74">${</span>OLD_IMAGE<span style="color:#e6db74">}</span> <span style="color:#e6db74">${</span>TOKEN<span style="color:#e6db74">}</span><span style="color:#66d9ef">)</span>

<span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> <span style="color:#e6db74">&#34;</span>$MANIFEST<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#66d9ef">$(</span>bin/docker-util/get-manifest.sh <span style="color:#e6db74">${</span>NEW_IMAGE<span style="color:#e6db74">}</span> <span style="color:#e6db74">${</span>TOKEN<span style="color:#e6db74">}</span><span style="color:#66d9ef">)</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span>
  <span style="color:#66d9ef">then</span>
    echo <span style="color:#e6db74">&#34;The new image is identical to the previous one, no deletion necessary&#34;</span>
    exit <span style="color:#ae81ff">0</span>
<span style="color:#66d9ef">fi</span>

docker pull <span style="color:#e6db74">${</span>NEW_IMAGE<span style="color:#e6db74">}</span>
docker tag <span style="color:#e6db74">${</span>NEW_IMAGE<span style="color:#e6db74">}</span> <span style="color:#e6db74">${</span>OLD_IMAGE<span style="color:#e6db74">}</span>
docker push <span style="color:#e6db74">${</span>OLD_IMAGE<span style="color:#e6db74">}</span>

echo <span style="color:#e6db74">&#34;Deleting the previous image, using the previously fetched manifest...&#34;</span>
bin/docker-util/delete-image.sh <span style="color:#e6db74">${</span>OLD_IMAGE<span style="color:#e6db74">}</span> <span style="color:#e6db74">${</span>MANIFEST<span style="color:#e6db74">}</span> <span style="color:#e6db74">${</span>TOKEN<span style="color:#e6db74">}</span>
</code></pre></div><p>The script executes <strong>a very important check</strong> before proceeding to re-tag and delete: it compares the SHA digest of the two images. This is needed because <strong>it&rsquo;s possible to produce two identical images</strong> in two different builds, so we could be in the situation where the two tags point to the same image, and so nothing should be done. If the next build will produce a different image, the fact that the multiple previous tags point to the same image will mean that the cascade deletion will take care of all with a single action.</p>
<p>The last thing that I could add to this deploy pipeline is the cleanup in case the deployment fails; it would be identical to the <code>delete-ci-image</code>, with the only exceptions that I would use the <code>prod</code> commit-specific tags and I would set <code>when: failure</code> option. Since <strong>in GitLab CI each single job is retriable</strong>, I can retry the deploy without executing the whole pipeline from the start, so I decided to not implement it for now.</p>
<h1 id="conclusions">Conclusions</h1>
<p>I hope that this (long) blog post will help people with this list of tips and tricks, and help save some time; many of the things that I wrote about here are not properly documented, so I learned them by trial and error and exercising some google-fu. I just hope that the GitLab registry will soon implement some easier and automatic way to do the cleanup, so all this hassle will be reduced to just a couple of YAML configuration lines.</p>

        </div>
        
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5 0 11V3C0 1.5.8.8.8.8S1.5 0 3 0h8c1.5 0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/></svg>
	<ul class="tags__list">
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/continuous-integration/" rel="tag">Continuous integration</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/continuous-deployment/" rel="tag">Continuous deployment</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/docker/" rel="tag">Docker</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/gitlab/" rel="tag">GitLab</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/kubernetes/" rel="tag">Kubernetes</a>
		</li>
	</ul>
</div>
    </article>
</main>

<div class="authorbox clearfix">
	<figure class="authorbox__avatar">
		<img alt="Alessandro Lai avatar" src="/images/avatar-alessandro-lai.jpg" class="avatar" height="90" width="90">
	</figure>
	<div class="authorbox__header">
		<span class="authorbox__name">About Alessandro Lai</span>
	</div>
	<div class="authorbox__description">
		Lead project developer at Facile.it, PHP-FIG secretary, PHP User Group Milano coordinator. Father, husband, computer science passionate, retired netgaming nerd. I love working with PHP, Symfony, Docker and Kubernetes.
	</div>
</div>

<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/phpunit-upgrade-namespace/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">How to gradually upgrade toward PHPUnit 6 with namespaced classes</p>
		</a>
	</div>
</nav>


			</div>
			<aside class="sidebar"><div class="widget-search widget">
	<form class="widget-search__form" role="search" method="get" action="https://duckduckgo.com/">
		<label>
			<input class="widget-search__field" type="search" placeholder="SEARCH…" value="" name="q" aria-label="SEARCH…">
		</label>
		<input class="widget-search__submit" type="submit" value="Search">
		<input type="hidden" name="sites" value="https://alessandrolai.dev/"/>
	</form>
</div>
<div class="widget-recent widget">
	<h4 class="widget__title">Recent Posts</h4>
	<div class="widget__content">
		<ul class="widget__list">
			<li class="widget__item"><a class="widget__link" href="/talks/2021-pugmi-my-functional-testing-toolbox/">My Symfony functional testing toolbox</a></li>
			<li class="widget__item"><a class="widget__link" href="/releases/pretty-package-versions/2.0.0/">Pretty Package Versions 2.0</a></li>
			<li class="widget__item"><a class="widget__link" href="/talks/2020-sfday-my-functional-testing-toolbox/">My Symfony functional testing toolbox</a></li>
			<li class="widget__item"><a class="widget__link" href="/releases/paraunit/1.2.0/">Paraunit 1.2.0: PHP 8 &amp; PHPUnit 9.3 support</a></li>
			<li class="widget__item"><a class="widget__link" href="/releases/pretty-package-versions/1.5.1/">Pretty Package Versions 1.5.1</a></li>
		</ul>
	</div>
</div>
<div class="widget-recent widget">
    <h4 class="widget__title">Recent Talks</h4>
    <div class="widget__content">
        <ul class="widget__list">
            <li class="widget__item"><a class="widget__link" href="/talks/2021-pugmi-my-functional-testing-toolbox/">
                My Symfony functional testing toolbox
                <br>
                <small>January 20 @ PUG Milano</small>
            </a></li>
            <li class="widget__item"><a class="widget__link" href="/talks/2020-sfday-my-functional-testing-toolbox/">
                My Symfony functional testing toolbox
                <br>
                <small>November 20 @ SFDay 2020</small>
            </a></li>
            <li class="widget__item"><a class="widget__link" href="/talks/2020-phpday-k8s-for-php-developers/">
                Kubernetes for PHP developers
                <br>
                <small>September 8 @ PHPDay 2020</small>
            </a></li>
            <li class="widget__item"><a class="widget__link" href="/talks/2020-01-facile-it-code-review/">
                Code reviews -  How-to, do &amp; dont&#39;s
                <br>
                <small>January 10 @ Facile.it IT meeting (internal)</small>
            </a></li>
            <li class="widget__item"><a class="widget__link" href="/talks/2019-symfonycon-event-sourcing/">
                Adding Event Sourcing to an existing PHP project (for the right reasons)
                <br>
                <small>November 21 @ SymfonyCon Amsterdam 2019</small>
            </a></li>
        </ul>
    </div>
</div>

<div class="widget-taglist widget">
	<h4 class="widget__title">Tags</h4>
	<div class="widget__content">
		<a class="widget-taglist__link widget__link btn" href="/tags/continuous-deployment/" title="Continuous deployment">Continuous deployment</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/continuous-integration/" title="Continuous integration">Continuous integration</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/database/" title="Database">Database</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/docker/" title="Docker">Docker</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/doctrine/" title="Doctrine">Doctrine</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/gitlab/" title="GitLab">GitLab</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/kubernetes/" title="Kubernetes">Kubernetes</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/mysql/" title="MySQL">MySQL</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/oop/" title="OOP">OOP</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/open-source/" title="Open Source">Open Source</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/paraunit/" title="Paraunit">Paraunit</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/php/" title="PHP">PHP</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/pretty-package-versions/" title="Pretty Package Versions">Pretty Package Versions</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/software-testing/" title="Software Testing">Software Testing</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/symfony/" title="Symfony">Symfony</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/tdd/" title="TDD">TDD</a>
	</div>
</div>
<div class="widget-social widget">
	<h4 class="widget-social__title widget__title">Social</h4>
	<div class="widget-social__content widget__content">
		<div class="widget-social__item widget__item">
			<a class="widget-social__link widget__link btn" title="Twitter" rel="noopener noreferrer" href="https://twitter.com/AlessandroLai" target="_blank">
				<svg class="widget-social__link-icon icon icon-twitter" width="24" height="24" viewBox="0 0 384 312"><path d="m384 36.9c-14.1 6.3-29.3 10.5-45.2 12.4 16.3-9.7 28.8-25.2 34.6-43.6-15.2 9-32.1 15.6-50 19.1-14.4-15.2-34.9-24.8-57.5-24.8-43.5 0-78.8 35.3-78.8 78.8 0 6.2.7 12.2 2 17.9-65.5-3.3-123.5-34.6-162.4-82.3-6.7 11.6-10.6 25.2-10.6 39.6 0 27.3 13.9 51.4 35 65.6-12.9-.4-25.1-4-35.7-9.9v1c0 38.2 27.2 70 63.2 77.2-6.6 1.8-13.6 2.8-20.8 2.8-5.1 0-10-.5-14.8-1.4 10 31.3 39.1 54.1 73.6 54.7-27 21.1-60.9 33.7-97.8 33.7-6.4 0-12.6-.4-18.8-1.1 34.9 22.4 76.3 35.4 120.8 35.4 144.9 0 224.1-120 224.1-224.1 0-3.4-.1-6.8-.2-10.2 15.4-11.1 28.7-25 39.3-40.8z"/></svg>
				<span>Twitter</span>
			</a>
		</div>
		<div class="widget-social__item widget__item">
			<a class="widget-social__link widget__link btn" title="LinkedIn" rel="noopener noreferrer" href="https://linkedin.com/in/alessandro-lai-09440922" target="_blank">
				<svg class="widget-social__link-icon icon icon-linkedin" width="24" height="24" viewBox="0 0 352 352"><path d="M0,40v272c0,21.9,18.1,40,40,40h272c21.9,0,40-18.1,40-40V40c0-21.9-18.1-40-40-40H40C18.1,0,0,18.1,0,40z M312,32 c4.6,0,8,3.4,8,8v272c0,4.6-3.4,8-8,8H40c-4.6,0-8-3.4-8-8V40c0-4.6,3.4-8,8-8H312z M59.5,87c0,15.2,12.3,27.5,27.5,27.5 c15.2,0,27.5-12.3,27.5-27.5c0-15.2-12.3-27.5-27.5-27.5C71.8,59.5,59.5,71.8,59.5,87z M187,157h-1v-21h-45v152h47v-75 c0-19.8,3.9-39,28.5-39c24.2,0,24.5,22.4,24.5,40v74h47v-83.5c0-40.9-8.7-72-56.5-72C208.5,132.5,193.3,145.1,187,157z M64,288h47.5 V136H64V288z"/></svg>
				<span>LinkedIn</span>
			</a>
		</div>
		<div class="widget-social__item widget__item">
			<a class="widget-social__link widget__link btn" title="GitHub" rel="noopener noreferrer" href="https://github.com/Jean85" target="_blank">
				<svg class="widget-social__link-icon icon icon-github" width="24" height="24" viewBox="0 0 384 374"><path d="m192 0c-106.1 0-192 85.8-192 191.7 0 84.7 55 156.6 131.3 181.9 9.6 1.8 13.1-4.2 13.1-9.2 0-4.6-.2-16.6-.3-32.6-53.4 11.6-64.7-25.7-64.7-25.7-8.7-22.1-21.3-28-21.3-28-17.4-11.9 1.3-11.6 1.3-11.6 19.3 1.4 29.4 19.8 29.4 19.8 17.1 29.3 44.9 20.8 55.9 15.9 1.7-12.4 6.7-20.8 12.2-25.6-42.6-4.8-87.5-21.3-87.5-94.8 0-20.9 7.5-38 19.8-51.4-2-4.9-8.6-24.3 1.9-50.7 0 0 16.1-5.2 52.8 19.7 15.3-4.2 31.7-6.4 48.1-6.5 16.3.1 32.7 2.2 48.1 6.5 36.7-24.8 52.8-19.7 52.8-19.7 10.5 26.4 3.9 45.9 1.9 50.7 12.3 13.4 19.7 30.5 19.7 51.4 0 73.7-44.9 89.9-87.7 94.6 6.9 5.9 13 17.6 13 35.5 0 25.6-.2 46.3-.2 52.6 0 5.1 3.5 11.1 13.2 9.2 76.2-25.5 131.2-97.3 131.2-182 0-105.9-86-191.7-192-191.7z"/></svg>
				<span>GitHub</span>
			</a>
		</div>
		<div class="widget-social__item widget__item">
			<a class="widget-social__link widget__link btn" title="GitLab" rel="noopener noreferrer" href="https://gitlab.com/Alessandro.Lai" target="_blank">
				<svg class="widget-social__link-icon icon icon-gitlab" width="24" height="24" viewBox="0 0 265 265"><path d="M128.075 236.075l47.104-144.97H80.97l47.104 144.97z M14.956 91.104L.642 135.16a9.752 9.752 0 0 0 3.542 10.903l123.891 90.012-113.12-144.97z M14.956 91.105H80.97L52.601 3.79c-1.46-4.493-7.816-4.492-9.275 0l-28.37 87.315z M241.194 91.104l14.314 44.056a9.752 9.752 0 0 1-3.543 10.903l-123.89 90.012 113.119-144.97z M241.194 91.105h-66.015l28.37-87.315c1.46-4.493 7.816-4.492 9.275 0l28.37 87.315z"/></svg>
				<span>GitLab</span>
			</a>
		</div>

		
	</div>
</div>
</aside>
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2021 Alessandro Lai.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>